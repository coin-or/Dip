*** mcknap.c	1998-03-13 10:14:59.000000000 -0500
--- /users/magala/COIN/coin-Dip/build-g/Dip/examples/ExternalSolvers/Knapsack/Pisinger/mcknap.c	2009-10-23 12:30:47.000000000 -0400
***************
*** 51,228 ****
   */
  
  
! /* ======================================================================
!                                   definitions
!    ====================================================================== */
! 
! #define TRACELEVEL  0                /* level of debug information */
! #define START       1                /* first test to be run */
! #define TESTS       100              /* last test to be run */
! 
! #include <stdlib.h>
! #include <stdio.h>
! #include <time.h>
! #include <stdarg.h>
! #include <values.h>
! #include <math.h>
! #include <string.h>
! #include <values.h>
! #include <limits.h>
! #include <malloc.h>
! #define _INCLUDE_POSIX_SOURCE
! #include <sys/times.h>
! #include <unistd.h>
! 
! 
! /* ======================================================================
! 				   macros
!    ====================================================================== */
! 
! #define srand(x)    srand48(x)
! #define random(x)   (lrand48() % (x))
! 
! #define SYNC           5   /* when to switch to linear scan in binary scan */
! #define MEDIMAX        15
! #define MAXSTACK       100
! #define MAXLIST        32
! #define MAXVTYPE       ULONG_MAX
! 
! #define TRUE           1
! #define FALSE          0
! 
! #define MAXIMIZE       0
! #define MINIMIZE       1
! 
! #define DET(a1, a2, b1, b2)    ((a1) * (stype) (b2) - (a2) * (stype) (b1))
! #define SWAPS(a,b)      { register itemset t; t=*(a); *(a)=*(b); *(b)=t; }
! #define SWAPI(a,b)      { register itemrec t; t=*(a); *(a)=*(b); *(b)=t; }
! #define SWAPO(a,b)      { register ordrec  t; t=*(a); *(a)=*(b); *(b)=t; }
! #define SIZE(a)                          ((int) (((a)->lset+1)-(a)->fset))
! 
! 
! /* ======================================================================
! 				 type declarations
!    ====================================================================== */
! 
! typedef int           boolean; /* logical variable */
! typedef int           ntype;   /* number of stages */
! typedef short         itype;   /* item profits and weights */
! typedef long          stype;   /* sum of pofit or weight */
! typedef unsigned long vtype;   /* solution vector */
! 
! /* partial vector */
! typedef struct {
!   stype    psum;
!   stype    wsum;
!   vtype    vect;
! } partvect;
! 
! /* item */
! typedef struct {
!   itype    psum;
!   itype    wsum;
! } itemrec;
! 
! /* set of partial vectors */
! typedef struct {
!   ntype    size;
!   itemrec  *fset;
!   itemrec  *lset;
!   itemrec  *no;
!   itemrec  f,l;
!   boolean  used;
! } itemset;
! 
! /* set of partial vectors */
! typedef struct {
!   ntype    size;
!   partvect *fset;
!   partvect *lset;
! } partset;
! 
! /* set of itemsets */
! typedef struct {
!   itemset  *fset;
!   itemset  *lset;
!   ntype    size;
! } isetset;
! 
! /* order record */
! typedef struct {
!   itype    dp;
!   itype    dw;
!   itemset  *ref;
! } ordrec;
! 
! /* order interval */
! typedef struct {
!   ordrec   *f;
!   ordrec   *l;
! } ordintv;
! 
! /* order stack */
! typedef struct {
!   ordintv  intv[MAXSTACK];
!   int      level;
!   int      optim;
!   ordrec   *first;
!   ordrec   *last;
!   ordrec   *i;
! } ordstack;
! 
! /* solution record */
! typedef struct {
!   ntype    size;
!   itemset  *set;
! } solrec;
! 
! /* solution structure */
! typedef struct {
!   solrec   list[MAXLIST];
!   ntype    size;
!   stype    psum;
!   stype    wsum;
!   vtype    vect;
!   vtype    vmax;
!   ordrec   *a;
!   ordrec   *b;
! } solstruct;
! 
! typedef int (*funcptr) (const void *, const void *);
! 
! 
! typedef struct { /* all problem information */
!   ntype k;
!   ntype n;
!   int   type;
!   itype range;
! 
!   stype capacity;	      /* capacity of knapsack */
!   stype dantzig;              /* the dantzig upper bound */
!   stype zstar;                /* optimal solution */
!   stype summul;	  	      /* sum of multiplications */
!   stype antmul;		      /* number of multiplications */
!   stype maxmul;               /* max multiplied set */
!   stype redusets;             /* sum of reduced sets */
!   stype reduitems;            /* sum of items which are tested for reduce */
!   stype redukill;             /* sum of tested items which were reduced */
!   stype gap;                  /* current gap */
!   stype partitions;           /* number of partitions */
!   stype domikill;             /* number of dominated-kills */
!   stype lpkill;               /* number of lp-kills */
!   long  timepar;              /* time used for partitioning */
!   long  timesort;             /* time used for sorting of gradients */
!   long  time;                 /* time used for all solution */
!   long  welldef;              /* is the found solution correct */
!   long  checked;              /* optimal solution checked */
!   long  iterates;             /* number of iterations to find optimal sol */
! } allinfo;
! 
! 
! /* ======================================================================
! 				  global variables
!    ====================================================================== */
! 
  solstruct solution;
  solstruct optsol;
  
--- 51,57 ----
   */
  
  
! #include "mcknap.h"
  solstruct solution;
  solstruct optsol;
  
***************
*** 238,243 ****
--- 68,74 ----
  double tot1, tot2;
  char lines[100];
  
+ #ifndef _MSC_VER
  /* due to failure in include library, the following must be included */
  struct tms timestart, timeend;
  
***************
*** 250,259 ****
  
  void showtime(void)
  {
!   double t1, t2;
    times(&timeend);
    t1 = (double) (timeend.tms_utime-timestart.tms_utime) / sysconf(_SC_CLK_TCK);
!   fprintf(trace, "%.2lf", t1);
  }
  
  
--- 81,90 ----
  
  void showtime(void)
  {
!   double t1;
    times(&timeend);
    t1 = (double) (timeend.tms_utime-timestart.tms_utime) / sysconf(_SC_CLK_TCK);
!   fprintf(trace, "%.2f", t1);
  }
  
  
***************
*** 264,272 ****
    t1 = (double) (timeend.tms_utime-timestart.tms_utime) / sysconf(_SC_CLK_TCK);
    t2 = (double) (timeend.tms_stime-timestart.tms_stime) / sysconf(_SC_CLK_TCK);
    tot1 += t1; tot2 += t2;
!   *time = t1 * 1000;
  }
! 
  
  void inittrace(char *ext)
  {
--- 95,103 ----
    t1 = (double) (timeend.tms_utime-timestart.tms_utime) / sysconf(_SC_CLK_TCK);
    t2 = (double) (timeend.tms_stime-timestart.tms_stime) / sysconf(_SC_CLK_TCK);
    tot1 += t1; tot2 += t2;
!   *time = (long)(t1 * 1000);
  }
! #endif
  
  void inittrace(char *ext)
  {
***************
*** 276,283 ****
    strcpy(s, "trace.");
    strcat(s, ext);
    trace = fopen(s,"a");
!   if (trace == NULL) printf("trace not openn\n");
!   tot1 = 0; 
    tot2 = 0;
    tracelevel = TRACELEVEL;
    traceniveau = 0;
--- 107,114 ----
    strcpy(s, "trace.");
    strcat(s, ext);
    trace = fopen(s,"a");
!   if (trace == NULL) DEBUG(printf("trace not openn\n"));
!   tot1 = 0;
    tot2 = 0;
    tracelevel = TRACELEVEL;
    traceniveau = 0;
***************
*** 294,325 ****
  
    if (level <= tracelevel) {
      va_start(args, s);
!     memcpy(t, lines, 2*traceniveau);
      strcpy(t + 2*traceniveau, "/");
      vsprintf(t + 2*traceniveau + 1, s, args);
      fprintf(trace, "%s\n", t);
!     if (traceconsole) printf("%s\n", t);
      va_end(args);
    }
    traceniveau++;
  }
  
  
! void vis(int level, char *s, ...)
  {
    va_list args;
    char t[500];
  
    if (level <= tracelevel) {
      va_start(args, s);
!     memcpy(t, lines, 2*traceniveau);
      vsprintf(t + 2*traceniveau, s, args);
      if (level == 0) {
!       printf("%s", t);
        fprintf(trace, "%s", t);
      } else {
        fprintf(trace, "%s", t);
!       if (traceconsole) printf("%s", t);
      }
      va_end(args);
    }
--- 125,156 ----
  
    if (level <= tracelevel) {
      va_start(args, s);
!     memcpy(t, lines, (size_t)(2*traceniveau));
      strcpy(t + 2*traceniveau, "/");
      vsprintf(t + 2*traceniveau + 1, s, args);
      fprintf(trace, "%s\n", t);
!     if (traceconsole) DEBUG(printf("%s\n", t));
      va_end(args);
    }
    traceniveau++;
  }
  
  
! void vis(int level, const char *s, ...)
  {
    va_list args;
    char t[500];
  
    if (level <= tracelevel) {
      va_start(args, s);
!     memcpy(t, lines, (size_t)(2*traceniveau));
      vsprintf(t + 2*traceniveau, s, args);
      if (level == 0) {
!       DEBUG(printf("%s", t));
        fprintf(trace, "%s", t);
      } else {
        fprintf(trace, "%s", t);
!       if (traceconsole) DEBUG(printf("%s", t));
      }
      va_end(args);
    }
***************
*** 334,344 ****
    traceniveau--;
    if (level <= tracelevel) {
      va_start(args, s);
!     memcpy(t, lines, 2*traceniveau);
      strcpy(t + 2*traceniveau, "\\");
      vsprintf(t + 2*traceniveau + 1, s, args);
      fprintf(trace, "%s\n", t);
!     if (traceconsole) printf("%s\n", t);
      va_end(args);
    }
  }
--- 165,175 ----
    traceniveau--;
    if (level <= tracelevel) {
      va_start(args, s);
!     memcpy(t, lines, (size_t)(2*traceniveau));
      strcpy(t + 2*traceniveau, "\\");
      vsprintf(t + 2*traceniveau + 1, s, args);
      fprintf(trace, "%s\n", t);
!     if (traceconsole) DEBUG(printf("%s\n", t));
      va_end(args);
    }
  }
***************
*** 346,354 ****
  
  void closetrace(void)
  {
!   int i;
! 
!   fflush(trace); 
    fclose(trace);
  }
  
--- 177,183 ----
  
  void closetrace(void)
  {
!   fflush(trace);
    fclose(trace);
  }
  
***************
*** 357,373 ****
  				  error
     ======================================================================= */
  
! void error(char *str, ...)
  {
    va_list args;
  
    va_start(args, str);
    vprintf(str, args);
!   printf("\n");
    vfprintf(trace, str, args);
    fprintf(trace, "\n");
    va_end(args);
!   printf("THE PROGRAM IS TERMINATED !!!\n\n");
    fprintf(trace, "THE PROGRAM IS TERMINATED !!!\n\n");
    closetrace();
    exit(-1);
--- 186,202 ----
  				  error
     ======================================================================= */
  
! void error(const char *str, ...)
  {
    va_list args;
  
    va_start(args, str);
    vprintf(str, args);
!   DEBUG(printf("\n"));
    vfprintf(trace, str, args);
    fprintf(trace, "\n");
    va_end(args);
!   DEBUG(printf("THE PROGRAM IS TERMINATED !!!\n\n"));
    fprintf(trace, "THE PROGRAM IS TERMINATED !!!\n\n");
    closetrace();
    exit(-1);
***************
*** 378,383 ****
--- 207,213 ----
                                    checktime
     ====================================================================== */
  
+ #ifndef _MSC_VER
  void checktime(void)
  {
    boolean first;
***************
*** 390,400 ****
      t = localtime(&s);
      if ((t->tm_wday == 0) || (t->tm_wday ==  6)) break;
      if ((t->tm_hour <  8) || (t->tm_hour >= 17)) break;
!     if (first) printf("sleeping\n");
      sleep(60);
    }
  }
! 
  
  /* ======================================================================
  				  palloc
--- 220,230 ----
      t = localtime(&s);
      if ((t->tm_wday == 0) || (t->tm_wday ==  6)) break;
      if ((t->tm_hour <  8) || (t->tm_hour >= 17)) break;
!     if (first) DEBUG(printf("sleeping\n"));
      sleep(60);
    }
  }
! #endif
  
  /* ======================================================================
  				  palloc
***************
*** 405,411 ****
    void * m;
    if (size == 0) size = 1;
    if (size != (size_t) size) error("Alloc too big %ld", size);
!   m = malloc(size);
    if (m == NULL) error("Alloc no space %ld", size);
    return m;
  }
--- 235,241 ----
    void * m;
    if (size == 0) size = 1;
    if (size != (size_t) size) error("Alloc too big %ld", size);
!   m = malloc((size_t)size);
    if (m == NULL) error("Alloc no space %ld", size);
    return m;
  }
***************
*** 476,490 ****
  {
    itemrec *i, *im;
  
!   vis(1,"ITEMSET: size %d choice (%hd,%hd)\n",
!       d->size, d->f.psum, d->f.wsum);
    im = d->lset;
    for (i = d->fset; i <= im; i++) {
      vis(1,"    (%hd,%hd)\n", i->psum, i->wsum);
    }
- }
  
  
  /* ======================================================================
  			       sumdata
     ====================================================================== */
--- 306,331 ----
  {
    itemrec *i, *im;
  
!   /*vis(1,"ITEMSET: size %d choice (%hd,%hd)\n",
!     d->size, d->f.psum, d->f.wsum);*/
!   fflush(stdout);
!   vis(1,"ITEMSET: size %d choice \n",
!       d->size);
    im = d->lset;
    for (i = d->fset; i <= im; i++) {
      vis(1,"    (%hd,%hd)\n", i->psum, i->wsum);
    }
  
+   DEBUG(printf("ITEMSET: size %d choice \n",
+ 	 d->size));
+   im = d->lset;
+   for (i = d->fset; i <= im; i++)
+     DEBUG(printf("  (i:%d,j:%d)  (p:%d,w:%d)\n",
+ 		 i->i, i->j,
+ 		 i->psum, i->wsum));
+ }
  
+ #if 0
  /* ======================================================================
  			       sumdata
     ====================================================================== */
***************
*** 520,526 ****
      mean     = tottime / (1000 * (double) TESTS);
      variance = sqtime / TESTS - mean * mean;
      stddev   = sqrt(variance);
!     redupct  = (reduitems == 0 ? 
                  0.0 : 100 * (double) redukill / (double) reduitems);
      fprintf(trace,"k        = %ld\n", k);
      fprintf(trace,"n        = %ld\n", n);
--- 361,367 ----
      mean     = tottime / (1000 * (double) TESTS);
      variance = sqtime / TESTS - mean * mean;
      stddev   = sqrt(variance);
!     redupct  = (reduitems == 0 ?
                  0.0 : 100 * (double) redukill / (double) reduitems);
      fprintf(trace,"k        = %ld\n", k);
      fprintf(trace,"n        = %ld\n", n);
***************
*** 571,577 ****
      t = a->type;
    }
  }
! 
  
  /* ======================================================================
  				 checksolution
--- 412,418 ----
      t = a->type;
    }
  }
! #endif
  
  /* ======================================================================
  				 checksolution
***************
*** 654,660 ****
     ====================================================================== */
  
  boolean definesol(allinfo *al, stype fixp, stype fixw,
!                   ordstack *a, ordstack *b, stype *c, stype *z, stype *ub)
  {
    vtype vect, rem;
    stype psum, wsum;
--- 495,502 ----
     ====================================================================== */
  
  boolean definesol(allinfo *al, stype fixp, stype fixw,
!                   ordstack *a, ordstack *b, stype *c, stype *z, stype *ub,
! 		  stype *obj)
  {
    vtype vect, rem;
    stype psum, wsum;
***************
*** 665,674 ****
  
    vect = optsol.vect;
    psum = optsol.psum; wsum  = optsol.wsum;
!   vis(1,"definesolution size %d, (%ld,%ld) vect %ld vmax %ld\n",
!       optsol.size, psum, wsum, vect, optsol.vmax);
!   vis(1,"definesolution maengde a: %d, b: %d\n",
!      optsol.a - a->first, b->last - optsol.b);
  
    /* prepare sets for next iteration */
    for (i = a->first; i <= optsol.a; i++)
--- 507,516 ----
  
    vect = optsol.vect;
    psum = optsol.psum; wsum  = optsol.wsum;
!   DEBUG(printf("definesolution size %d, (%g,%g) vect %ld vmax %ld\n",
!                optsol.size, psum, wsum, vect, optsol.vmax));
!   DEBUG(printf("definesolution maengde a: %ld, b: %ld\n",
!                 optsol.a - a->first, b->last - optsol.b));
  
    /* prepare sets for next iteration */
    for (i = a->first; i <= optsol.a; i++)
***************
*** 681,697 ****
      s = &(optsol.list[k]);
      rem  = vect  % s->size;
      jc = s->set->fset + rem;
!     vis(2,"choice no %ld of %hd is (%hd,%hd)\n",
! 	rem, s->size, jc->psum, jc->wsum);
      psum -= jc->psum - s->set->f.psum;
      wsum -= jc->wsum - s->set->f.wsum;
      s->set->f    = *jc;  /* save choice in f */
      s->set->used = TRUE; /* avoid recalculation */
      vect  = vect  / s->size;
    }
!   vis(2,"FINAL sum %ld,%ld, break %ld,%ld\n", psum, wsum, fixp, fixw);
    al->welldef = (fixp == psum) && (fixw == wsum);
!   if (al->welldef) return TRUE;
  
    /* new problem */
    *z = psum - 1; *c = wsum; *ub = psum;
--- 523,542 ----
      s = &(optsol.list[k]);
      rem  = vect  % s->size;
      jc = s->set->fset + rem;
!     DEBUG(printf("choice no %ld of %hd is (%hd,%hd)\n",
!                  rem, s->size, jc->psum, jc->wsum));
      psum -= jc->psum - s->set->f.psum;
      wsum -= jc->wsum - s->set->f.wsum;
      s->set->f    = *jc;  /* save choice in f */
      s->set->used = TRUE; /* avoid recalculation */
      vect  = vect  / s->size;
    }
!   DEBUG(printf("FINAL sum %g,%g, break %g,%g\n", psum, wsum, fixp, fixw));
    al->welldef = (fixp == psum) && (fixw == wsum);
!   if (al->welldef){
!     *obj = psum;
!     return TRUE;
!   }
  
    /* new problem */
    *z = psum - 1; *c = wsum; *ub = psum;
***************
*** 737,761 ****
  
  int icmp(itype *a, itype *b) { return *a - *b; }
  
  void maketest(itemset *j, int r, int type)
  {
    register itemrec *i;
    itemrec *im;
!   itype *p, *w;
    stype ps, ws;
    ntype k, n;
  
    n = j->size;
    if (type == 3) r = (2*r) / n;
    if ((type == 3) || (type == 5)) {
!     p = palloc(n * (long) sizeof(itype));
!     w = palloc(n * (long) sizeof(itype));
      for (k = 0; k < n; k++) {
        w[k] = random(r) + 1;
        p[k] = (type == 3 ? w[k] + 10 : random(r) + 1);
      }
!     qsort(p, n, sizeof(itype), (funcptr) icmp);
!     qsort(w, n, sizeof(itype), (funcptr) icmp);
    }
  
    im = j->lset; ps = 0; ws = 0;
--- 582,607 ----
  
  int icmp(itype *a, itype *b) { return *a - *b; }
  
+ #ifndef _MSC_VER
  void maketest(itemset *j, int r, int type)
  {
    register itemrec *i;
    itemrec *im;
!   itype *p = NULL, *w = NULL;
    stype ps, ws;
    ntype k, n;
  
    n = j->size;
    if (type == 3) r = (2*r) / n;
    if ((type == 3) || (type == 5)) {
!     p = (itype*) palloc(n * (long) sizeof(itype));
!     w = (itype*) palloc(n * (long) sizeof(itype));
      for (k = 0; k < n; k++) {
        w[k] = random(r) + 1;
        p[k] = (type == 3 ? w[k] + 10 : random(r) + 1);
      }
!     qsort(p, (size_t)n, sizeof(itype), (funcptr) icmp);
!     qsort(w, (size_t)n, sizeof(itype), (funcptr) icmp);
    }
  
    im = j->lset; ps = 0; ws = 0;
***************
*** 792,797 ****
--- 638,646 ----
      pfree(p);
      pfree(w);
    }
+ 
+   /* MVG */
+   visitems(j);
  }
  
  
***************
*** 802,821 ****
  stype inititems(allinfo *al, isetset *h,
                  ntype classes, int size, int r, int type)
  {
!   itemset *j, *jm, *k;
    itemrec *i, *im, *mi, *ma;
    stype wsum1, wsum2;
  
    /* init itemset */
    h->size  = classes;
!   h->fset  = palloc(h->size * (long) sizeof(itemset));
    h->lset  = h->fset + h->size - 1;
  
    /* generate test classes */
    jm = h->lset;
    for (j = h->fset; j <= jm; j++) {
      j->size = size;
!     j->fset = palloc(size * (long) sizeof(itemrec));
      j->lset = j->fset + size - 1;
      maketest(j, r, type);
    }
--- 651,670 ----
  stype inititems(allinfo *al, isetset *h,
                  ntype classes, int size, int r, int type)
  {
!   itemset *j, *jm;
    itemrec *i, *im, *mi, *ma;
    stype wsum1, wsum2;
  
    /* init itemset */
    h->size  = classes;
!   h->fset  = (itemset*) palloc(h->size * (long) sizeof(itemset));
    h->lset  = h->fset + h->size - 1;
  
    /* generate test classes */
    jm = h->lset;
    for (j = h->fset; j <= jm; j++) {
      j->size = size;
!     j->fset = (itemrec*) palloc(size * (long) sizeof(itemrec));
      j->lset = j->fset + size - 1;
      maketest(j, r, type);
    }
***************
*** 835,845 ****
      wsum2 += ma->wsum;
    }
    al->capacity = (wsum1 + wsum2) / 2;
!   vis(2,"SETS %hd, MINW %ld, MAXW %ld, C %ld\n",
        classes, wsum1, wsum2, al->capacity);
    return al->capacity;
  }
! 
  
  /* ======================================================================
  				    merge
--- 684,694 ----
      wsum2 += ma->wsum;
    }
    al->capacity = (wsum1 + wsum2) / 2;
!   vis(2,"SETS %hd, MINW %g, MAXW %g, C %g\n",
        classes, wsum1, wsum2, al->capacity);
    return al->capacity;
  }
! #endif
  
  /* ======================================================================
  				    merge
***************
*** 857,863 ****
  
      d  = jset->size;
      j1 = jset->fset; jm = jset->lset;
!     *k1 = palloc((d+1) * (long) sizeof(partvect));/* 1 extra is used below */
      *km = *k1 + d - 1;
      i = iset->fset + f;         /* add item i minus lp-choice in set iset */
      psum = i->psum - iset->f.psum;
--- 706,712 ----
  
      d  = jset->size;
      j1 = jset->fset; jm = jset->lset;
!     *k1 = (partvect*) palloc((d+1) * (long) sizeof(partvect));/* 1 extra is used below */
      *km = *k1 + d - 1;
      i = iset->fset + f;         /* add item i minus lp-choice in set iset */
      psum = i->psum - iset->f.psum;
***************
*** 878,884 ****
      merge(jset, iset, f+d+1, l,   &b1, &bm);
  
      size = (am - a1 + 1) + (long) (bm - b1 + 1) + 1; /* 1 extra used below */
!     *k1 = palloc(size * (long) sizeof(partvect));
      a = a1; b = b1; k = *k1;
      if (a->wsum <= b->wsum) { *k = *a; a++; } else { *k = *b; b++; }
      (am+1)->wsum = bm->wsum + 1; (am+1)->psum = 0;/* add max as extra item */
--- 727,733 ----
      merge(jset, iset, f+d+1, l,   &b1, &bm);
  
      size = (am - a1 + 1) + (long) (bm - b1 + 1) + 1; /* 1 extra used below */
!     *k1 = (partvect*) palloc(size * (long) sizeof(partvect));
      a = a1; b = b1; k = *k1;
      if (a->wsum <= b->wsum) { *k = *a; a++; } else { *k = *b; b++; }
      (am+1)->wsum = bm->wsum + 1; (am+1)->psum = 0;/* add max as extra item */
***************
*** 914,920 ****
  {
    partvect *k1, *km;
    ntype size;
-   vtype vmax;
  
    rotatesol(a, b);
    merge(a, b, 0, b->size-1, &k1, &km);
--- 763,768 ----
***************
*** 922,928 ****
    a->fset = k1;
    a->lset = km;
    size = SIZE(a);
!   vis(2,"MULTIPLY (%ld*%ld) = %ld -> %ld\n",
        (long) a->size, (long) b->size, a->size * (long) b->size, (long) size);
    a->size = size;
    if (size > al->maxmul) al->maxmul = size;
--- 770,776 ----
    a->fset = k1;
    a->lset = km;
    size = SIZE(a);
!   vis(2,"MULTIPLY (%g*%g) = %g -> %g\n",
        (long) a->size, (long) b->size, a->size * (long) b->size, (long) size);
    a->size = size;
    if (size > al->maxmul) al->maxmul = size;
***************
*** 968,974 ****
    for (i = v+1; i <= rm; i++) {
      if (DET(i->psum-z, i->wsum-c, ps, ws) >= 0) { *k = *i; k++; }
    }
!   vis(2,"Z=%ld, reduceset %3d -> %3d  s(%hd,%hd) t(%hd,%hd)\n",
        *z1, (int) a->size, (int) (k - a->fset), ps, ws, pt, wt);
    a->lset = k - 1;
    a->size = SIZE(a);
--- 816,822 ----
    for (i = v+1; i <= rm; i++) {
      if (DET(i->psum-z, i->wsum-c, ps, ws) >= 0) { *k = *i; k++; }
    }
!   vis(2,"Z=%g, reduceset %3d -> %3d  s(%hd,%hd) t(%hd,%hd)\n",
        *z1, (int) a->size, (int) (k - a->fset), ps, ws, pt, wt);
    a->lset = k - 1;
    a->size = SIZE(a);
***************
*** 983,989 ****
  		itype pb, itype wb, stype z1, stype c)
  {
    register itemrec *i;
!   stype z, ub, psum1, wsum1;
    itemrec *i1, *im;
  
    if (a->size == 1) return;
--- 831,837 ----
  		itype pb, itype wb, stype z1, stype c)
  {
    register itemrec *i;
!   stype z, psum1, wsum1;
    itemrec *i1, *im;
  
    if (a->size == 1) return;
***************
*** 998,1007 ****
    for (i = i1; i <= im; ) {
      al->reduitems++;
      psum1 = i->psum + psum; wsum1 = i->wsum + wsum;
!     if (DET(psum1-z,wsum1-c,pb,wb) >= 0) { i++; } 
      else { SWAPI(i,im); im--; al->redukill++; }
    }
!   vis(2,"Z=%ld, reitem %3d -> %3d\n",
        z1, (int) a->size, (int) (i - a->fset));
    a->lset = i - 1;
    a->size = SIZE(a);
--- 846,855 ----
    for (i = i1; i <= im; ) {
      al->reduitems++;
      psum1 = i->psum + psum; wsum1 = i->wsum + wsum;
!     if (DET(psum1-z,wsum1-c,pb,wb) >= 0) { i++; }
      else { SWAPI(i,im); im--; al->redukill++; }
    }
!   vis(2,"Z=%g, reitem %3d -> %3d\n",
        z1, (int) a->size, (int) (i - a->fset));
    a->lset = i - 1;
    a->size = SIZE(a);
***************
*** 1028,1040 ****
      im = j->lset;
      f = l = im;
      for (i = j->fset; i < im; i++) {
!       if (i->wsum <  f->wsum) f = i;
        if (i->psum >= l->psum) {
! 	if ((i->psum > l->psum) || (i->wsum < l->wsum)) l = i;
        }
      }
!     j->f = *f; minw += f->wsum;
!     j->l = *l; maxw += l->wsum;
  
      /* now remove dominated */
      lw = l->wsum; SWAPI(j->fset,l);
--- 876,896 ----
      im = j->lset;
      f = l = im;
      for (i = j->fset; i < im; i++) {
!        /*printf("  i->wsum=%d i->psum=%d\n", i->wsum, i->psum);*/
!       if (i->wsum <  f->wsum)
!         f = i;
        if (i->psum >= l->psum) {
! 	if ((i->psum > l->psum) || (i->wsum < l->wsum))
!           l = i;
        }
      }
!     j->f = *f;
!     minw += f->wsum;
!     j->l = *l;
! 
!     maxw += l->wsum;
!     /*printf("l->wsum: %d l->psum: %d maxw: %d\n",
!       l->wsum, l->psum, maxw);*/
  
      /* now remove dominated */
      lw = l->wsum; SWAPI(j->fset,l);
***************
*** 1052,1058 ****
      }
    }
    head->lset = jm;
!   vis(2,"now %hd fix (%ld,%ld) kill %hd\n", head->size, *fixp, *fixw, kill);
    *minw1 = minw; *maxw1 = maxw;
  }
  
--- 908,915 ----
      }
    }
    head->lset = jm;
!   DEBUG(printf("now %hd fix (%g,%g) kill %ld\n",
!                head->size, *fixp, *fixw, kill));
    *minw1 = minw; *maxw1 = maxw;
  }
  
***************
*** 1073,1079 ****
  void choosemedian(isetset *head, itype *cdp, itype *cdw)
  {
    int d;
-   itype dp, dw;
    itemset *i;
    ordrec a[MEDIMAX];
  
--- 930,935 ----
***************
*** 1083,1089 ****
      a[d].dw = i->l.wsum - i->f.wsum;
    }
  
!   qsort(&a, d, sizeof(ordrec), (funcptr) lamless);
    *cdp = a[d/2].dp; *cdw = a[d/2].dw;
    vis(2,"\nmedian (%hd,%hd)\n", *cdp, *cdw);
  }
--- 939,945 ----
      a[d].dw = i->l.wsum - i->f.wsum;
    }
  
!   qsort(&a, (size_t)d, sizeof(ordrec), (funcptr) lamless);
    *cdp = a[d/2].dp; *cdw = a[d/2].dw;
    vis(2,"\nmedian (%hd,%hd)\n", *cdp, *cdw);
  }
***************
*** 1096,1102 ****
  void outermost(isetset *head, itype dp, itype dw,
  	       stype *minwsum, stype *maxwsum)
  {
!   register itemrec *i, *no;
    itemrec *i1, *im;
    itemset *j, *jm;
    stype sum, msum;
--- 952,958 ----
  void outermost(isetset *head, itype dp, itype dw,
  	       stype *minwsum, stype *maxwsum)
  {
!   register itemrec *i, *no = NULL;
    itemrec *i1, *im;
    itemset *j, *jm;
    stype sum, msum;
***************
*** 1140,1146 ****
    register itemrec *i, *im;
    itemrec *i1;
    itemset *j, *jm;
!   itype p1, w1, pm, wm;
    long dkill, left, setout;
  
    dkill = left = setout = 0;
--- 996,1002 ----
    register itemrec *i, *im;
    itemrec *i1;
    itemset *j, *jm;
!   itype p1, wm;
    long dkill, left, setout;
  
    dkill = left = setout = 0;
***************
*** 1191,1197 ****
  {
    register itemrec *i;
    stype ps, ws;
!   itemrec *i1, *im, *choice;
    itemset *j, *jm, *cut;
  
    /* define solution: first choose smallest items */
--- 1047,1053 ----
  {
    register itemrec *i;
    stype ps, ws;
!   itemrec *i1, *im;
    itemset *j, *jm, *cut;
  
    /* define solution: first choose smallest items */
***************
*** 1225,1231 ****
  				  partition
     ====================================================================== */
  
! void partition(allinfo *al, isetset *head, stype c,
                 stype *psum, stype *wsum, itype *dp, itype *dw)
  {
    stype fixp, fixw, minwsum, maxwsum;
--- 1081,1087 ----
  				  partition
     ====================================================================== */
  
! int partition(allinfo *al, isetset *head, stype c,
                 stype *psum, stype *wsum, itype *dp, itype *dw)
  {
    stype fixp, fixw, minwsum, maxwsum;
***************
*** 1234,1241 ****
  
    /* check for trivial solutions and reduce trivially dominated */
    preprocess(head, &fixp, &fixw, &minwsum, &maxwsum);
!   if ((minwsum > c) || (maxwsum <= c)) return;
  
    for (;;) {
      al->partitions++;
      choosemedian(head, dp, dw);
--- 1090,1108 ----
  
    /* check for trivial solutions and reduce trivially dominated */
    preprocess(head, &fixp, &fixw, &minwsum, &maxwsum);
!   DEBUG(printf("\nminwsum: %g, maxwsum: %g, c: %g",
! 	 minwsum, maxwsum, c));
  
+   /*MVG: have to deal with trivial cases separate*/
+   if(minwsum > c){
+      DEBUG(printf("\nMCKNAP_RC_INF"));
+      return MCKNAP_RC_INF;
+   }
+   if(maxwsum <= c){
+      /*DEBUG(printf("\nMCKNAP_RC_TRIVIAL_MAXSUM"));*/
+      return MCKNAP_RC_TRIVIAL_MAXSUM;
+   }
+   
    for (;;) {
      al->partitions++;
      choosemedian(head, dp, dw);
***************
*** 1245,1251 ****
      outermost(head, *dp, *dw, &minwsum, &maxwsum);
  
      /* now consider the weight sums */
!     vis(2,"wsum %ld-%ld: c %ld\n", minwsum, maxwsum, c);
      if ((minwsum <= c) && (c <= maxwsum)) break;
  
      /* separete set in dominated and live items */
--- 1112,1120 ----
      outermost(head, *dp, *dw, &minwsum, &maxwsum);
  
      /* now consider the weight sums */
!     DEBUG(printf("wsum %g-%g: c %g\n", minwsum, maxwsum, c));
!     fflush(stdout);
!     vis(2,"wsum %g-%g: c %g\n", minwsum, maxwsum, c);
      if ((minwsum <= c) && (c <= maxwsum)) break;
  
      /* separete set in dominated and live items */
***************
*** 1256,1263 ****
  
    *psum = fixp; *wsum = fixw;
    al->dantzig = fixp + ((c - fixw) * *dp) / *dw;
!   vis(1,"UB=%ld Z=%ld FIXED (%ld,%ld) BREAK (%hd,%hd) CAP %ld\n",
        al->dantzig, fixp, fixp, fixw, *dp, *dw, al->capacity);
  }
  
  
--- 1125,1135 ----
  
    *psum = fixp; *wsum = fixw;
    al->dantzig = fixp + ((c - fixw) * *dp) / *dw;
!   vis(1,"UB=%g Z=%g FIXED (%g,%g) BREAK (%hd,%hd) CAP %g\n",
        al->dantzig, fixp, fixp, fixw, *dp, *dw, al->capacity);
+   DEBUG(printf("UB=%g Z=%g FIXED (%g,%g) BREAK (%hd,%hd) CAP %g\n",
+       al->dantzig, fixp, fixp, fixw, *dp, *dw, al->capacity));
+   return MCKNAP_RC_OK;
  }
  
  
***************
*** 1278,1284 ****
      psum -= j->f.psum;
      wsum -= j->f.wsum;
    }
!   if ((psum != 0) || (wsum != 0)) error("choices not first");
  }
  
  
--- 1150,1159 ----
      psum -= j->f.psum;
      wsum -= j->f.wsum;
    }
!   if ((psum != 0) || (wsum != 0)){
!     DEBUG(printf("\npsum: %g, wsum: %g", psum, wsum));
!     error("choices not first");
!   }
  }
  
  
***************
*** 1303,1312 ****
    i1 = mid->fset; im = mid->lset;
    if (i1 == im) return;
  
!   qsort(mid->fset, SIZE(mid), sizeof(itemrec), (funcptr) itemless);
  
    /* now remove dominated */
!   k1 = palloc(mid->size * (long) sizeof(itemrec));
    for (i = i1+1, j = i1, k = k1; i <= im; i++ ) {
      if (i->psum > j->psum) { j++; *j = *i; } else { *k = *i; k++; }
    }
--- 1178,1187 ----
    i1 = mid->fset; im = mid->lset;
    if (i1 == im) return;
  
!   qsort(mid->fset, (size_t)SIZE(mid), sizeof(itemrec), (funcptr) itemless);
  
    /* now remove dominated */
!   k1 = (itemrec*) palloc(mid->size * (long) sizeof(itemrec));
    for (i = i1+1, j = i1, k = k1; i <= im; i++ ) {
      if (i->psum > j->psum) { j++; *j = *i; } else { *k = *i; k++; }
    }
***************
*** 1330,1336 ****
    partvect *j;
  
    domiitem(old);
!   mid->fset = palloc(old->size * (long) sizeof(partvect));
    i1 = old->fset; im = old->lset;
    psum -= old->f.psum; wsum -= old->f.wsum; /* subtract lp-choice */
    for (i = i1, j = mid->fset; i <= im; i++) {
--- 1205,1211 ----
    partvect *j;
  
    domiitem(old);
!   mid->fset = (partvect*) palloc(old->size * (long) sizeof(partvect));
    i1 = old->fset; im = old->lset;
    psum -= old->f.psum; wsum -= old->f.wsum; /* subtract lp-choice */
    for (i = i1, j = mid->fset; i <= im; i++) {
***************
*** 1392,1398 ****
  
  void checkinterval(ordstack *s)
  {
-   int l;
    ordintv *top;
  
    if (s->level == -1) return; /* nothing to pop */
--- 1267,1272 ----
***************
*** 1448,1455 ****
  
  void makestacks(ordstack *stacka, ordstack *stackb, isetset *head)
  {
!   stacka->first = palloc(head->size * (long) sizeof(ordrec));
!   stackb->first = palloc(head->size * (long) sizeof(ordrec));
    stacka->last  = stacka->first + head->size - 1;
    stackb->last  = stackb->first + head->size - 1;
    stacka->level = -1;
--- 1322,1329 ----
  
  void makestacks(ordstack *stacka, ordstack *stackb, isetset *head)
  {
!   stacka->first = (ordrec*) palloc(head->size * (long) sizeof(ordrec));
!   stackb->first = (ordrec*) palloc(head->size * (long) sizeof(ordrec));
    stacka->last  = stacka->first + head->size - 1;
    stackb->last  = stackb->first + head->size - 1;
    stacka->level = -1;
***************
*** 1475,1492 ****
  /* ======================================================================
  				 minmcknap
     ====================================================================== */
! 
  void minmcknap(ntype k, ntype n, itype r, int type)
  {
    allinfo a;
    ordstack stacka, stackb;
!   stype cstar, psum, wsum, z, c, ub;
    partset mid;
    isetset head;
    itemset *s;
    itype pb, wb;
    boolean optimal;
!   int i;
  
    a.k        = k;
    a.n        = n;
--- 1349,1367 ----
  /* ======================================================================
  				 minmcknap
     ====================================================================== */
! #ifndef _MSC_VER
  void minmcknap(ntype k, ntype n, itype r, int type)
  {
    allinfo a;
    ordstack stacka, stackb;
!   stype cstar, psum = 0, wsum = 0, z, c, ub;
    partset mid;
    isetset head;
    itemset *s;
    itype pb, wb;
+   stype obj = 0;
    boolean optimal;
!   int i, stat;
  
    a.k        = k;
    a.n        = n;
***************
*** 1504,1523 ****
    a.redukill = 0;
    a.domikill = 0;
  
    starttime();
  
    c = cstar;
    makestacks(&stacka, &stackb, &head);
!   partition(&a, &head, c, &psum, &wsum, &pb, &wb);
    restore(&head, psum, wsum);
    endtime(&a.timepar);
    if (psum == a.dantzig) {
      stacka.i->dp = pb; stacka.i->dw = wb; stacka.i->ref = head.fset;
      stackb.i->dp = pb; stackb.i->dw = wb; stackb.i->ref = head.fset;
    } else {
      defineedges(&stacka, &stackb, &head);
    }
    endtime(&a.timesort);
  
    z = psum-1; ub = a.dantzig;
    for (i = 1; ; i++) {
--- 1379,1407 ----
    a.redukill = 0;
    a.domikill = 0;
  
+ #ifndef _MSC_VER
    starttime();
+ #endif
  
    c = cstar;
    makestacks(&stacka, &stackb, &head);
!   stat = partition(&a, &head, c, &psum, &wsum, &pb, &wb);
!   DEBUG(printf("\nc: %g, psum: %g, wsum: %g", c, psum, wsum));
!   if(stat != MCKNAP_RC_OK)
!     return;
    restore(&head, psum, wsum);
+ #ifndef _MSC_VER
    endtime(&a.timepar);
+ #endif
    if (psum == a.dantzig) {
      stacka.i->dp = pb; stacka.i->dw = wb; stacka.i->ref = head.fset;
      stackb.i->dp = pb; stackb.i->dw = wb; stackb.i->ref = head.fset;
    } else {
      defineedges(&stacka, &stackb, &head);
    }
+ #ifndef _MSC_VER
    endtime(&a.timesort);
+ #endif
  
    z = psum-1; ub = a.dantzig;
    for (i = 1; ; i++) {
***************
*** 1558,1584 ****
        }
      }
      if (i == 1) a.zstar = z;
!     optimal = definesol(&a, psum, wsum, &stacka, &stackb, &c, &z, &ub);
      pfree(mid.fset);
      if (optimal) { a.iterates += i; break; }
!     vis(1,"TUR TIL MED c %ld, z %ld, ub %ld\n", c, z, ub);
      if (i > 10) error("for mange runder");
    }
  
    a.gap = a.dantzig - a.zstar;
    freestacks(&stacka, &stackb);
  
    endtime(&a.time);
    checksolution(&a, &head, a.zstar, cstar);
!   sumdata(&a);
    freeitems(&head);
  }
  
  
  /* ======================================================================
  				    main
     ====================================================================== */
! 
  void main(int argc, char *argv[])
  {
    int n, r, k, type, v;
--- 1442,1643 ----
        }
      }
      if (i == 1) a.zstar = z;
!     optimal = definesol(&a, psum, wsum, &stacka, &stackb, &c, &z, &ub, &obj);
      pfree(mid.fset);
      if (optimal) { a.iterates += i; break; }
!     vis(1,"TUR TIL MED c %g, z %g, ub %g\n", c, z, ub);
      if (i > 10) error("for mange runder");
    }
  
    a.gap = a.dantzig - a.zstar;
    freestacks(&stacka, &stackb);
  
+ #ifndef _MSC_VER
    endtime(&a.time);
+ #endif
    checksolution(&a, &head, a.zstar, cstar);
!   /*sumdata(&a);*/
    freeitems(&head);
  }
+ #endif
+ 
+ /* ======================================================================
+ 				 minmcknap
+    ====================================================================== */
+ 
+ int minmcknapSolve(int cap,
+ 		   isetset * head,
+ 		   itemrec * solRec,
+ 		   stype   * minObj){
+   allinfo a;
+   ordstack stacka, stackb;
+   stype cstar, psum = 0, wsum = 0, z, c, ub;
+   partset mid;
+   itemset *s;
+   itype pb, wb;
+   boolean optimal;
+   stype obj = 0;
+   int i, status;
+   ntype k = head->size;
+ 
+   a.k        = k;
+   a.n        = 0;
+   a.range    = 0;
+   a.type     = 0;
+   a.capacity = cap;
+   cstar = cap;
+   a.summul   = 0;
+   a.maxmul   = 0;
+   a.antmul   = 0;
+   a.redusets = 0;
+   a.reduitems= 0;
+   a.redukill = 0;
+   a.domikill = 0;
+   *minObj    = -999999;
+ 
+ #ifndef _MSC_VER
+   starttime();
+ #endif
+ 
+ #if 0
+   {
+      itemset *jm, *j;
+      DEBUG(printf("\nat start\n"));
+      jm = head->lset;
+      for(j = head->fset; j <= jm; j++){
+ 	visitems(j);
+      }
+   }
+ #endif
+ 
+ 
+   c = cstar;
+   makestacks(&stacka, &stackb, head);
+   status = partition(&a, head, c, &psum, &wsum, &pb, &wb);
+   DEBUG(printf("\nc: %g, psum: %g, wsum: %g, a.dantzig: %g",
+                c, psum, wsum, a.dantzig));
+   if(status != MCKNAP_RC_OK){
+      freestacks(&stacka, &stackb);
+      return status;
+   }
+ 
+   restore(head, psum, wsum);
+   DEBUG(printf("\nafter restore psum: %g, wsum: %g", psum, wsum));
+ #ifndef _MSC_VER
+   endtime(&a.timepar);
+ #endif
+   if (psum == a.dantzig) {
+     stacka.i->dp = pb; stacka.i->dw = wb; stacka.i->ref = head->fset;
+     stackb.i->dp = pb; stackb.i->dw = wb; stackb.i->ref = head->fset;
+   } else {
+     defineedges(&stacka, &stackb, head);
+   }
+ #ifndef _MSC_VER
+   endtime(&a.timesort);
+ #endif
  
+   z = psum-1; ub = a.dantzig;
+   for (i = 1; ; i++) {
+     DEBUG(printf("\n==== loop i: %d", i));
+     initfirst(&mid, head->fset, psum, wsum);
+     for (;;) {
+       reduceset(&mid, stacka.i, stackb.i, &z, c);
+       DEBUG(printf("\n1 - mid.size: %d, z: %g, ub: %g",
+                    mid.size, z, ub));
+       if ((mid.size == 0) || (z == ub)) break;
+ 
+       s = stacka.i->ref; if (s == NULL) break;
+       (stacka.i)++; checkinterval(&stacka);
+       if (!s->used) {
+ 	reduceitem(&a, s, psum, wsum, pb, wb, z, c);
+ 	domiitem(s);
+ 	if (s->size > 1) {
+ 	  multiply(&a, &mid, s);
+ 	  a.antmul++;
+ 	  a.summul += mid.size;
+ 	  if (mid.size > a.maxmul) a.maxmul = mid.size;
+ 	}
+ 	s->used = TRUE;
+       }
+ 
+       reduceset(&mid, stacka.i, stackb.i, &z, c);
+       DEBUG(printf("\n2 - mid.size: %d, z: %g, ub: %g",
+                    mid.size, z, ub));
+       if ((mid.size == 0) || (z == ub)) break;
+ 
+       s = stackb.i->ref; if (s == NULL) break;
+       (stackb.i)--; checkinterval(&stackb);
+       if (!s->used) {
+ 	reduceitem(&a, s, psum, wsum, pb, wb, z, c);
+ 	domiitem(s);
+ 	if (s->size > 1) {
+ 	  multiply(&a, &mid, s);
+ 	  a.antmul++;
+ 	  a.summul += mid.size;
+ 	  if (mid.size > a.maxmul) a.maxmul = mid.size;
+ 	}
+ 	s->used = TRUE;
+       }
+     }
+     if (i == 1) a.zstar = z;
+     optimal = definesol(&a, psum, wsum, &stacka, &stackb, &c, &z, &ub, &obj);
+     pfree(mid.fset);
+     if (optimal) { a.iterates += i; break; }
+     vis(1,"TUR TIL MED c %g, z %g, ub %g\n", c, z, ub);
+     if (i > 10) error("for mange runder");
+   }
+ 
+   a.gap = a.dantzig - a.zstar;
+   freestacks(&stacka, &stackb);
+ 
+ #ifndef _MSC_VER
+   endtime(&a.time);
+ #endif
+ 
+   checksolution(&a, head, a.zstar, cstar);
+   /*visitems(optsol.list[0].set);
+ 
+   //save optimal solution vector
+   //assert(optsol.size == 1);
+   //if(optsol.size != 1){
+   //   printf("\nERROR");
+   //   abort();
+   //}*/
+   
+ #if 0
+   for(i=0; i < optsol.size; i++){
+      visitems(optsol.list[i].set);
+   }
+   /*visitems(optsol.list[0].set);*/
+   for(i = 0; i < k; i++){
+      solRec[i] = optsol.list[optsol.size-1].set[i].f;    
+   }
+ #endif
+ 
+ #if 1
+   {
+      itemset *jm, *j;
+      i  = 0;
+      jm = head->lset;
+      for(j = head->fset; j <= jm; j++){
+ 	/*visitems(j);*/
+ 	solRec[i] = j->f;
+ 	i++;
+      }
+   }
+ #endif
+   
+     
+   /*sumdata(&a);*/
+   /*freeitems(head);*/
+   *minObj = obj;
+   return MCKNAP_RC_OK;
+ }
  
  /* ======================================================================
  				    main
     ====================================================================== */
! #if 0
  void main(int argc, char *argv[])
  {
    int n, r, k, type, v;
***************
*** 1590,1606 ****
      n = atoi(argv[2]);
      r = atoi(argv[3]);
      type = atoi(argv[4]);
!     printf("Mcknap %d %d %d %d\n", k, n, r, type);
    } else {
!     printf("Mcknap\n");
!     printf("k = "); scanf("%d", &k);
!     printf("n = "); scanf("%d", &n);
!     printf("r = "); scanf("%d", &r);
!     printf("t = "); scanf("%d", &type);
    }
  
    inittrace("mc");
!   fprintf(trace,"\nMCKNAP: k: %d, n: %d, r: %d, type: %d\n", k, n, r, type);
  
    for (v = START; v <= TESTS; v++) {
      srand(v);
--- 1649,1665 ----
      n = atoi(argv[2]);
      r = atoi(argv[3]);
      type = atoi(argv[4]);
!     DEBUG(printf("Mcknap %d %d %d %d\n", k, n, r, type);
    } else {
!     DEBUG(printf("Mcknap\n");
!     DEBUG(printf("k = "); scanf("%d", &k);
!     DEBUG(printf("n = "); scanf("%d", &n);
!     DEBUG(printf("r = "); scanf("%d", &r);
!     DEBUG(printf("t = "); scanf("%d", &type);
    }
  
    inittrace("mc");
!   fprinft(trace,"\nMCKNAP: k: %d, n: %d, r: %d, type: %d\n", k, n, r, type);
  
    for (v = START; v <= TESTS; v++) {
      srand(v);
***************
*** 1612,1619 ****
      minmcknap(k, n, r, type);
    }
  
!   sumdata(NULL);
    closetrace();
  }
! 
  
--- 1671,1678 ----
      minmcknap(k, n, r, type);
    }
  
!   /*sumdata(NULL);*/
    closetrace();
  }
! #endif
  
